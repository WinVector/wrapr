<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="John Mount" />

<meta name="date" content="2018-12-05" />

<title>Function Objects</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#header {
text-align: center;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; }  code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>

</head>

<body>




<h1 class="title toc-ignore">Function Objects</h1>
<h4 class="author"><em>John Mount</em></h4>
<h4 class="date"><em>2018-12-05</em></h4>



<p>Composing functions and sequencing operations are core programming concepts.</p>
<p>Some notable realizations of sequencing or pipelining operations include:</p>
<ul>
<li>Unix’s <a href="https://en.wikipedia.org/wiki/Pipeline_(Unix)"><code>|</code>-pipe</a></li>
<li><a href="https://en.wikipedia.org/wiki/CMS_Pipelines">CMS Pipelines</a>.</li>
<li><code>F#</code>’s forward pipe operator <code>|&gt;</code>.</li>
<li>Haskel’s Data.Function <code>&amp;</code> operator.</li>
<li>The <a href="https://www.r-project.org"><code>R</code></a> <a href="https://CRAN.R-project.org/package=magrittr"><code>magrittr</code></a> forward pipe.</li>
<li><a href="https://scikit-learn.org/stable/index.html">Scikit-learn</a>’s <a href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html"><code>sklearn.pipeline.Pipeline</code></a>.</li>
</ul>
<p>The idea is: many important calculations can be considered as a sequence of transforms applied to a data set. Each step may be a function taking many arguments. It is often the case that only one of each function’s arguments is primary, and the rest are parameters. For data science applications this is particularly common, so having convenient pipeline notation can be a plus. An example of a non-trivial data processing pipeline can be found <a href="https://github.com/WinVector/vtreat/blob/master/extras/ModelingPipelines.md">here</a>.</p>
<p>In this note we will discuss the advanced <a href="https://www.r-project.org"><code>R</code></a> pipeline operator <a href="https://winvector.github.io/wrapr/reference/dot_arrow.html">“dot arrow pipe”</a> and an <code>S4</code> class (<a href="https://winvector.github.io/wrapr/index.html"><code>wrapr::UnaryFn</code></a>) that makes working with pipeline notation much more powerful and much easier.</p>
<p>The ideas are:</p>
<ul>
<li>The <a href="https://github.com/WinVector/wrapr"><code>wrapr</code></a> <a href="https://winvector.github.io/wrapr/reference/dot_arrow.html">dot arrow pipe</a> includes a detailed <code>S3</code>/<code>S4</code> configurable interface (detailed in the RJournal <a href="https://journal.r-project.org/archive/2018/RJ-2018-042/index.html">here</a>). These interfaces are able to treat objects as functions: i.e. they can pipe data into objects.</li>
<li>The <code>wrapr::UnaryFn</code> class supplies a convenient tool for the <a href="https://en.wikipedia.org/wiki/Partial_application">partial function application</a> needed to work with pipelines.</li>
</ul>
<p>Or: pipe notation assumes a world data transforms are single argument functions (with other parameters already bound in), and the <code>UnaryFn</code> derived classes we discuss here help realize such a world.</p>
<p>This can be made clearer with examples.</p>
<p>Suppose we build a linear model of <code>log(y)</code> as follows.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1">d &lt;-<span class="st"> </span><span class="kw">data.frame</span>(</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="dt">x =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>), </a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="dt">y =</span> <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">20</span>, <span class="dv">50</span>, <span class="dv">150</span>))</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">model &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="kw">log</span>(y) <span class="op">~</span><span class="st"> </span>x, <span class="dt">data =</span> d)</a></code></pre></div>
<p>We can see our predictions in original <code>y</code>-units by making the prediction and then exponentiation:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">exp</span>(<span class="kw">predict</span>(model, <span class="dt">newdata =</span> d))</a></code></pre></div>
<pre><code>##          1          2          3          4          5 
##   2.459509   6.770839  18.639596  51.313366 141.261725</code></pre>
<p>It is natural to want to apply a model later to new data. This can be done as follows.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1">d2 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">3</span><span class="op">:</span><span class="dv">7</span>)</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">exp</span>(<span class="kw">predict</span>(model, <span class="dt">newdata =</span> d2))</a></code></pre></div>
<pre><code>##          1          2          3          4          5 
##   18.63960   51.31337  141.26173  388.88260 1070.56368</code></pre>
<p>The <code>wrapr</code> package allows us to use a “piping into a function” notation as follows.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">library</span>(<span class="st">&quot;wrapr&quot;</span>)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">model_f &lt;-<span class="st"> </span><span class="cf">function</span>(df) {</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="kw">exp</span>(<span class="kw">predict</span>(model, <span class="dt">newdata =</span> df))</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">d2 <span class="op">%.&gt;%</span><span class="st"> </span>model_f</a></code></pre></div>
<pre><code>##          1          2          3          4          5 
##   18.63960   51.31337  141.26173  388.88260 1070.56368</code></pre>
<p>In the above example the <code>model</code> contents are captured in the function closure. However, it is better practice to explicitly store data in objects.</p>
<p><code>wrapr</code> supplies a method to do this, which we will now demonstrate.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" data-line-number="1">model_o &lt;-</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="st">  </span><span class="kw">fnlist</span>(</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    <span class="kw">pkgfn</span>(</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">      <span class="st">&quot;stats::predict.lm&quot;</span>,</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">      <span class="dt">arg_name =</span> <span class="st">&quot;newdata&quot;</span>, </a>
<a class="sourceLine" id="cb8-6" data-line-number="6">      <span class="dt">args =</span> <span class="kw">list</span>(<span class="dt">object =</span> model)),</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    <span class="kw">pkgfn</span>(</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">      <span class="st">&quot;exp&quot;</span>,</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">      <span class="dt">arg_name =</span> <span class="st">&quot;x&quot;</span>))</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  </a>
<a class="sourceLine" id="cb8-11" data-line-number="11"></a>
<a class="sourceLine" id="cb8-12" data-line-number="12"><span class="kw">cat</span>(<span class="kw">format</span>(model_o))</a></code></pre></div>
<pre><code>## UnaryFnList(
##    stats::predict.lm(newdata=., object),
##    base::exp(x=., ))</code></pre>
<p>Notice <code>model_o</code> is an object (not a function). However we can pipe into <code>model_o</code> as if it were a function.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1">d2 <span class="op">%.&gt;%</span><span class="st"> </span>model_o</a></code></pre></div>
<pre><code>##          1          2          3          4          5 
##   18.63960   51.31337  141.26173  388.88260 1070.56368</code></pre>
<p>This works because <code>model_o</code> is derived from the <code>S4</code> class <code>UnaryFn</code> and <code>wrapr</code> has definitions for <code>apply_right.UnaryFn</code> and <code>apply_left.UnaryFn</code>, which integrate this class into the <a href="https://winvector.github.io/wrapr/reference/dot_arrow.html"><code>wrapr</code> dot-arrow pipe</a>. The family of <code>UnaryFn</code> classes single argument functions. This system happens to be implemented by <code>wrapr</code>, but <code>wrapr</code> dot arrow extension mechanisms also allow users to build their own pipe-compatible systems. (<code>S3</code>/<code>S4</code> extension details can be found in the RJournal <a href="https://journal.r-project.org/archive/2018/RJ-2018-042/index.html">here</a>.</p>
<p>The pipe notation is not strictly required as the apply is done through the <code>S4</code> method <code>wrapr::ApplyTo()</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">ApplyTo</span>(model_o, d2) </a></code></pre></div>
<pre><code>##          1          2          3          4          5 
##   18.63960   51.31337  141.26173  388.88260 1070.56368</code></pre>
<p>The above methods can be used to wrap substantial functions such as <a href="https://winvector.github.io/vtreat/reference/prepare.html"><code>vtreat::prepare()</code></a> to create very powerful data processing pipelines. A more involved example of trying this technique can be found <a href="https://github.com/WinVector/vtreat/blob/master/extras/ModelingPipelines.md">here</a>.</p>
<p>Note: the <code>wrapr</code> right-dispatch we are using is only triggered when the right-hand side of a pipeline is a symbol or name. This is consistent with pipelines such as “<code>5 %.&gt;% sin</code>” where we are not so much piping into the sin-function, but into a name that refers to the sin-function. However, piping into names covers most practical cases.</p>
<p>We can apply processing pipelines piece by piece.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" data-line-number="1">pred_step &lt;-<span class="st"> </span><span class="kw">pkgfn</span>(</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="st">&quot;stats::predict.lm&quot;</span>,</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  <span class="dt">arg_name =</span> <span class="st">&quot;newdata&quot;</span>, </a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  <span class="dt">args =</span> <span class="kw">list</span>(<span class="dt">object =</span> model))</a>
<a class="sourceLine" id="cb14-5" data-line-number="5"></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">exp_step &lt;-<span class="st"> </span><span class="kw">pkgfn</span>(</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">  <span class="st">&quot;base::exp&quot;</span>,</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">  <span class="dt">arg_name =</span> <span class="st">&quot;x&quot;</span>)</a>
<a class="sourceLine" id="cb14-9" data-line-number="9"></a>
<a class="sourceLine" id="cb14-10" data-line-number="10">d2 <span class="op">%.&gt;%</span><span class="st"> </span>pred_step <span class="op">%.&gt;%</span><span class="st"> </span>exp_step</a></code></pre></div>
<pre><code>##          1          2          3          4          5 
##   18.63960   51.31337  141.26173  388.88260 1070.56368</code></pre>
<p>We can also build such a pipeline by piping pieces into each other.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" data-line-number="1">model_p &lt;-<span class="st"> </span>pred_step <span class="op">%.&gt;%</span><span class="st"> </span>exp_step</a>
<a class="sourceLine" id="cb16-2" data-line-number="2"></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="kw">cat</span>(<span class="kw">format</span>(model_p))</a></code></pre></div>
<pre><code>## UnaryFnList(
##    stats::predict.lm(newdata=., object),
##    base::exp(x=., ))</code></pre>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb18-1" data-line-number="1">d2 <span class="op">%.&gt;%</span><span class="st"> </span>model_p</a></code></pre></div>
<pre><code>##          1          2          3          4          5 
##   18.63960   51.31337  141.26173  388.88260 1070.56368</code></pre>
<p>The pipe notation is not required (but is a nice notation). The apply a list of function objects effect can be achieved directly with <code>wrapr::ApplyTo()</code>.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">ApplyTo</span>(model_p, d2)</a></code></pre></div>
<pre><code>##          1          2          3          4          5 
##   18.63960   51.31337  141.26173  388.88260 1070.56368</code></pre>
<p>The idea is: the processing pipelines store an arbitrary number of function objects as a simple list. The list declares function-like behavior to both <code>ApplyTo</code> and the <code>wrapr</code> dot-arrow pipe through <code>R</code> <code>S3</code>/<code>S4</code> class declarations. Function objects do not capture environments as function closures do (though obviously any function in them does have its own closure). List of function objects can be easier to work with, store, and share than function closures or other pipeline structures.</p>
<p>We can look at the contents of a pipeline as follows.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb22-1" data-line-number="1">model_p<span class="op">@</span>items</a></code></pre></div>
<pre><code>## [[1]]
## [1] &quot;stats::predict.lm(newdata=., object)&quot;
## 
## [[2]]
## [1] &quot;base::exp(x=., )&quot;</code></pre>
<p>In addition to the <code>PartialNamedFn</code> class we suggest looking at the following additional adapters:</p>
<ul>
<li><code>srcfn()</code> which accepts the source code for an arbitrary expression (quoted either with quote-marks or with <code>wrapr::qe()</code>).</li>
<li><code>wrapfn()</code> class which directly accepts a function (including the closure).</li>
</ul>
<p>Examples include:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb24-1" data-line-number="1">s4 &lt;-<span class="st"> </span><span class="kw">srcfn</span>(</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">  <span class="kw">qe</span>(. <span class="op">+</span><span class="st"> </span>y), </a>
<a class="sourceLine" id="cb24-3" data-line-number="3">  <span class="dt">arg_name =</span> <span class="st">&quot;.&quot;</span>, </a>
<a class="sourceLine" id="cb24-4" data-line-number="4">  <span class="dt">args=</span> <span class="kw">list</span>(<span class="dt">y=</span><span class="dv">13</span>))</a>
<a class="sourceLine" id="cb24-5" data-line-number="5"><span class="kw">print</span>(s4)</a></code></pre></div>
<pre><code>## [1] &quot;SrcFunction{ . + y }(.=., y)&quot;</code></pre>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="dv">22</span> <span class="op">%.&gt;%</span><span class="st"> </span>s4</a></code></pre></div>
<pre><code>## [1] 35</code></pre>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb28-1" data-line-number="1">s5 &lt;-<span class="st"> </span><span class="kw">wrapfn</span>(</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">  tan, </a>
<a class="sourceLine" id="cb28-3" data-line-number="3">  <span class="dt">arg_name =</span> <span class="st">&quot;x&quot;</span>)</a>
<a class="sourceLine" id="cb28-4" data-line-number="4"><span class="kw">print</span>(s5)</a></code></pre></div>
<pre><code>## [1] &quot;PartialFunction{tan}(x=., )&quot;</code></pre>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="dv">1</span><span class="op">:</span><span class="dv">4</span> <span class="op">%.&gt;%</span><span class="st"> </span>s5</a></code></pre></div>
<pre><code>## [1]  1.5574077 -2.1850399 -0.1425465  1.1578213</code></pre>
<p>For convenience <code>wrapr</code> <a href="https://winvector.github.io/wrapr/reference/dot_arrow.html">dot-pipe</a> pipeable object can be converted into a single-argument function of “dot” with the <a href="https://winvector.github.io/wrapr/reference/as_fn.html"><code>as_fn()</code></a> method:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb32-1" data-line-number="1">f5 &lt;-<span class="st"> </span><span class="kw">as_fn</span>(s5)</a>
<a class="sourceLine" id="cb32-2" data-line-number="2"></a>
<a class="sourceLine" id="cb32-3" data-line-number="3"><span class="kw">f5</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>)</a></code></pre></div>
<pre><code>## [1]  1.5574077 -2.1850399 -0.1425465  1.1578213 -3.3805150</code></pre>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="dv">1</span><span class="op">:</span><span class="dv">5</span> <span class="op">%.&gt;%</span><span class="st"> </span>f5</a></code></pre></div>
<pre><code>## [1]  1.5574077 -2.1850399 -0.1425465  1.1578213 -3.3805150</code></pre>
<p>The <code>UnaryFn</code> pipelines can also interpenetrate with <a href="https://winvector.github.io/rqdatatable/"><code>rqdatatable</code></a> pipelines.</p>
<p><code>wrapr</code> <code>UnaryFn</code> pipelines can also be placed inside (stricter, table oriented) <code>rqdatatable</code> pipelines.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="kw">library</span>(<span class="st">&quot;rqdatatable&quot;</span>)</a></code></pre></div>
<pre><code>## Loading required package: rquery</code></pre>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb38-1" data-line-number="1">upipe &lt;-<span class="st"> </span><span class="kw">fnlist</span>(</a>
<a class="sourceLine" id="cb38-2" data-line-number="2">  <span class="kw">pkgfn</span>(</a>
<a class="sourceLine" id="cb38-3" data-line-number="3">    <span class="st">&quot;stats::predict.lm&quot;</span>,</a>
<a class="sourceLine" id="cb38-4" data-line-number="4">    <span class="dt">arg_name =</span> <span class="st">&quot;newdata&quot;</span>, </a>
<a class="sourceLine" id="cb38-5" data-line-number="5">    <span class="dt">args =</span> <span class="kw">list</span>(<span class="dt">object =</span> model)),</a>
<a class="sourceLine" id="cb38-6" data-line-number="6">  <span class="kw">srcfn</span>(</a>
<a class="sourceLine" id="cb38-7" data-line-number="7">    <span class="kw">qe</span>(<span class="kw">data.frame</span>(<span class="dt">log_pred =</span> .))</a>
<a class="sourceLine" id="cb38-8" data-line-number="8">  ))</a>
<a class="sourceLine" id="cb38-9" data-line-number="9"></a>
<a class="sourceLine" id="cb38-10" data-line-number="10">d <span class="op">%.&gt;%</span><span class="st"> </span>upipe</a></code></pre></div>
<pre><code>##    log_pred
## 1 0.8999619
## 2 1.9126250
## 3 2.9252882
## 4 3.9379513
## 5 4.9506144</code></pre>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb40-1" data-line-number="1">ops &lt;-<span class="st"> </span><span class="kw">mk_td</span>(<span class="st">&quot;d&quot;</span>, <span class="st">&quot;x&quot;</span>) <span class="op">%.&gt;%</span></a>
<a class="sourceLine" id="cb40-2" data-line-number="2"><span class="st">  </span><span class="kw">rq_ufn</span>(., </a>
<a class="sourceLine" id="cb40-3" data-line-number="3">         upipe, </a>
<a class="sourceLine" id="cb40-4" data-line-number="4">         <span class="dt">columns_produced =</span> <span class="st">&quot;log_pred&quot;</span>) <span class="op">%.&gt;%</span></a>
<a class="sourceLine" id="cb40-5" data-line-number="5"><span class="st">  </span><span class="kw">extend</span>(.,</a>
<a class="sourceLine" id="cb40-6" data-line-number="6">         <span class="dt">pred =</span> <span class="kw">exp</span>(log_pred))</a>
<a class="sourceLine" id="cb40-7" data-line-number="7"></a>
<a class="sourceLine" id="cb40-8" data-line-number="8"><span class="kw">columns_used</span>(ops)</a></code></pre></div>
<pre><code>## $d
## [1] &quot;x&quot;</code></pre>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="kw">column_names</span>(ops)</a></code></pre></div>
<pre><code>## [1] &quot;log_pred&quot; &quot;pred&quot;</code></pre>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="kw">cat</span>(<span class="kw">format</span>(ops))</a></code></pre></div>
<pre><code>## table(d; 
##   x) %.&gt;%
##  non_sql_node(., UnaryFnList(
##    stats::predict.lm(newdata=., object),
##    SrcFunction{ data.frame(log_pred = .) }(.=., ))) %.&gt;%
##  extend(.,
##   pred := exp(log_pred))</code></pre>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb46-1" data-line-number="1">d <span class="op">%.&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb46-2" data-line-number="2"><span class="st">  </span>ops </a></code></pre></div>
<pre><code>##     log_pred       pred
## 1: 0.8999619   2.459509
## 2: 1.9126250   6.770839
## 3: 2.9252882  18.639596
## 4: 3.9379513  51.313366
## 5: 4.9506144 141.261725</code></pre>
<p>Or <code>rqdatatable</code> pipelines can be stored in <code>UnaryFn</code> nodes.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="kw">library</span>(<span class="st">&quot;rqdatatable&quot;</span>)</a>
<a class="sourceLine" id="cb48-2" data-line-number="2"></a>
<a class="sourceLine" id="cb48-3" data-line-number="3">d2 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb48-4" data-line-number="4"></a>
<a class="sourceLine" id="cb48-5" data-line-number="5">ops &lt;-<span class="st"> </span><span class="kw">mk_td</span>(<span class="st">&quot;d&quot;</span>, <span class="st">&quot;x&quot;</span>) <span class="op">%.&gt;%</span></a>
<a class="sourceLine" id="cb48-6" data-line-number="6"><span class="st">  </span><span class="kw">extend</span>(., <span class="dt">y =</span> x <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb48-7" data-line-number="7"></a>
<a class="sourceLine" id="cb48-8" data-line-number="8"><span class="kw">cat</span>(<span class="kw">format</span>(ops))</a></code></pre></div>
<pre><code>## table(d; 
##   x) %.&gt;%
##  extend(.,
##   y := x + 1)</code></pre>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb50-1" data-line-number="1">d2 <span class="op">%.&gt;%</span><span class="st"> </span>ops</a></code></pre></div>
<pre><code>##    x y
## 1: 1 2</code></pre>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb52-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">rq_fn_wrapper</span>(ops) <span class="op">%.&gt;%</span></a>
<a class="sourceLine" id="cb52-2" data-line-number="2"><span class="st">  </span><span class="kw">srcfn</span>(<span class="kw">qe</span>(.[, cname, <span class="dt">drop =</span> <span class="ot">TRUE</span>]),</a>
<a class="sourceLine" id="cb52-3" data-line-number="3">        <span class="dt">arg_name =</span> <span class="st">&quot;.&quot;</span>,</a>
<a class="sourceLine" id="cb52-4" data-line-number="4">        <span class="dt">args =</span> <span class="kw">list</span>(<span class="dt">cname =</span> <span class="st">&quot;y&quot;</span>))</a>
<a class="sourceLine" id="cb52-5" data-line-number="5"></a>
<a class="sourceLine" id="cb52-6" data-line-number="6"><span class="kw">cat</span>(<span class="kw">format</span>(p))</a></code></pre></div>
<pre><code>## UnaryFnList(
##    rq_u_fn_w{ table(d; 
##   x) %.&gt;%
##  extend(.,
##   y := x + 1)
##  },
##    SrcFunction{ .[, cname, drop = TRUE] }(.=., cname))</code></pre>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb54-1" data-line-number="1">d2 <span class="op">%.&gt;%</span><span class="st"> </span>p</a></code></pre></div>
<pre><code>## [1] 2</code></pre>
<p>The idea is <code>wrapr</code> supplies many possible variations of notations: functions sequences as lists, function composition by pipe, function composition by call, function application by pipe, and function application by call. Then the user can pick what notation they prefer. <code>rquery</code> pipelines are very restricted (they date <code>data.frame</code>s to <code>data.frame</code>s and pre-check a number of invariants). <code>UnaryFn</code> pipelines are more free-form, they check very little before application.</p>
<p>The demonstrated design and functionality is inspired by partially applied functions, but a bit more circumspect in what is carried around. In Lisp “code is data”, in <code>R</code> it is a bit more complicated- so a pure-data solution has some merits.</p>
<p>And these are the basics of <code>wrapr</code> function objects. For a more substantial data processing example please see <a href="https://github.com/WinVector/vtreat/blob/master/extras/ModelingPipelines.md">here</a>.</p>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>

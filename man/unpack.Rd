% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/unpack.R
\name{unpack}
\alias{unpack}
\title{Unpack or bind values into the calling environment.}
\usage{
unpack(wrapr_private_value, ...)
}
\arguments{
\item{wrapr_private_value}{list of values to copy}

\item{...}{argument names to write to}
}
\description{
Unpacks or binds values into the calling environment. Uses \code{bquote} escaping.
NULL is a special case that is unpacked to all targets. NA targets are skipped.
All non-NA target names must be unique.
}
\details{
Similar to \code{Python} tuple unpacking, \code{zeallot}'s arrow, and to \code{vadr::bind}.

Note: a reference to the unpacker object is written into the unpacking environment as a side-effect
of the implied array assignment.
Array-assign form can not use the names: \code{.}, \code{wrapr_private_self}, \code{value}, or \code{unpack}.
Function form can not use the names: \code{.} or \code{wrapr_private_value}.
}
\examples{

# named unpacking
# looks like assignment: destination = where_from_in_value
d <- data.frame(x = 1:2,
                g=c('test', 'train'),
                stringsAsFactors = FALSE)
unpack[train_set = train, test_set = test] <- split(d, d$g)
# train_set and test_set now correctly split
print(train_set)
print(test_set)

# name capture version
unpack[a, b] <- list(5, 10)
print(a)  # now 5
print(b)  # now 10

# bquote re-direct to value in variable using .()
# Note: the bquote .() step is potentially confusing, as the user
# can't immediately see where the value is being assigned to.
# Also, quotes are allowed.
a <- 'x'
unpack[.(a), 'b'] <- list(20, 40)
print(x)  # now 20
print(b)  # now 40
print(a)  # still 'x'

# pipe version
list(55, 15) \%.>\% unpack(., a, b)
print(a)  # now 55
print(b)  # now 15
# Note: the above example will not work with magrittr pipe,
# as in that case the values get written to an intermediate
# environment and lost.

}
